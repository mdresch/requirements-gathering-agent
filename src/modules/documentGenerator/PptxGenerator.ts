/**
 * PowerPoint Presentation Generator
 * Converts markdown content to properly formatted PowerPoint presentations (.pptx)
 */

import pptxgenjs from 'pptxgenjs';
import * as fs from 'fs/promises';
import * as path from 'path';

export interface PptxOptions {
    /** Presentation title */
    title: string;
    /** Presentation author */
    author?: string;
    /** Company/organization name */
    company?: string;
    /** Presentation description */
    description?: string;
    /** Theme for slides */
    theme?: 'default' | 'corporate' | 'modern' | 'minimal';
    /** Include table of contents slide */
    includeTOC?: boolean;
}

export class PptxGenerator {
    /**
     * Generate a PowerPoint presentation from markdown content
     */
    static async generatePresentation(
        content: string,
        outputPath: string,
        options: PptxOptions
    ): Promise<void> {
        try {
            const pptx = new pptxgenjs();
            
            // Set presentation metadata
            pptx.author = options.author || 'Requirements Gathering Agent';
            pptx.company = options.company || 'Generated by Requirements Gathering Agent';
            pptx.title = options.title;
            pptx.subject = options.description || 'PMBOK-compliant project documentation';

            // Apply theme
            this.applyTheme(pptx, options.theme || 'default');

            // Create title slide
            this.createTitleSlide(pptx, options);

            // Parse markdown and create slides
            const slides = this.parseMarkdownToSlides(content, options);
            
            // Add table of contents if requested
            if (options.includeTOC && slides.length > 0) {
                this.createTableOfContentsSlide(pptx, slides);
            }

            // Add content slides
            slides.forEach(slide => {
                this.createContentSlide(pptx, slide);
            });

            // Save presentation
            await pptx.writeFile({ fileName: outputPath });
            
            console.log(`✅ Generated PowerPoint presentation: ${outputPath}`);
        } catch (error: any) {
            console.error(`❌ Failed to generate PowerPoint presentation: ${error.message}`);
            throw error;
        }
    }

    /**
     * Parse markdown content into slide structure
     */
    private static parseMarkdownToSlides(content: string, options: PptxOptions): SlideContent[] {
        const lines = content.split('\n');
        const slides: SlideContent[] = [];
        let currentSlide: SlideContent | null = null;
        let inTable = false;
        let tableRows: string[][] = [];

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            
            if (!line && !inTable) continue;

            // H1 and H2 create new slides
            if (line.startsWith('# ') || line.startsWith('## ')) {
                // Save previous slide
                if (currentSlide) {
                    if (inTable && tableRows.length > 0) {
                        currentSlide.content.push({ type: 'table', data: tableRows });
                        tableRows = [];
                        inTable = false;
                    }
                    slides.push(currentSlide);
                }

                // Create new slide
                const level = line.startsWith('# ') ? 1 : 2;
                const title = line.replace(/^#+\s*/, '');
                currentSlide = {
                    title,
                    level,
                    content: []
                };
                continue;
            }

            if (!currentSlide) {
                // Create default slide if content appears before any header
                currentSlide = {
                    title: options.title || 'Content',
                    level: 1,
                    content: []
                };
            }

            // Handle tables
            if (line.includes('|') && line.split('|').length > 2) {
                const cells = line.split('|').map(cell => cell.trim()).filter(cell => cell);
                
                // Skip table separator lines
                if (cells.every(cell => /^[-\s:]+$/.test(cell))) {
                    continue;
                }
                
                tableRows.push(cells);
                inTable = true;
                continue;
            } else if (inTable) {
                // End of table
                currentSlide.content.push({ type: 'table', data: tableRows });
                tableRows = [];
                inTable = false;
            }

            // Handle H3-H6 as bullet points with different levels
            if (line.startsWith('###')) {
                const text = line.replace(/^###\s*/, '');
                currentSlide.content.push({ type: 'bullet', text, level: 3 });
                continue;
            }

            // Handle lists
            if (line.startsWith('- ') || line.startsWith('* ')) {
                const text = line.replace(/^[-*]\s*/, '');
                currentSlide.content.push({ type: 'bullet', text, level: 1 });
                continue;
            }

            // Handle numbered lists
            if (/^\d+\.\s/.test(line)) {
                const text = line.replace(/^\d+\.\s*/, '');
                currentSlide.content.push({ type: 'bullet', text, level: 1, numbered: true });
                continue;
            }

            // Handle regular text
            if (line && !line.startsWith('**') && !line.startsWith('*This document was generated')) {
                // Filter out metadata lines
                if (!line.includes('Generated:') && !line.includes('Document Version:')) {
                    currentSlide.content.push({ type: 'text', text: line });
                }
            }
        }

        // Add final slide
        if (currentSlide) {
            if (inTable && tableRows.length > 0) {
                currentSlide.content.push({ type: 'table', data: tableRows });
            }
            slides.push(currentSlide);
        }

        return slides;
    }

    /**
     * Apply theme to presentation
     */
    private static applyTheme(pptx: any, theme: string): void {
        switch (theme) {
            case 'corporate':
                pptx.defineLayout({ name: 'LAYOUT_4x3', width: 10, height: 7.5 });
                break;
            case 'modern':
                pptx.defineLayout({ name: 'LAYOUT_16x9', width: 13.33, height: 7.5 });
                break;
            case 'minimal':
                pptx.defineLayout({ name: 'LAYOUT_16x9', width: 13.33, height: 7.5 });
                break;
            default:
                pptx.defineLayout({ name: 'LAYOUT_16x9', width: 13.33, height: 7.5 });
        }
    }

    /**
     * Create title slide
     */
    private static createTitleSlide(pptx: any, options: PptxOptions): void {
        const slide = pptx.addSlide();
        
        // Title
        slide.addText(options.title, {
            x: 1,
            y: 2,
            w: 11.33,
            h: 1.5,
            fontSize: 36,
            bold: true,
            color: '2F5597',
            align: 'center'
        });

        // Subtitle
        slide.addText('PMBOK-Compliant Project Documentation', {
            x: 1,
            y: 3.5,
            w: 11.33,
            h: 0.8,
            fontSize: 18,
            color: '666666',
            align: 'center'
        });

        // Author and company
        const authorText = [
            options.author || 'Requirements Gathering Agent',
            options.company || '',
            new Date().toLocaleDateString()
        ].filter(Boolean).join('\n');

        slide.addText(authorText, {
            x: 1,
            y: 5.5,
            w: 11.33,
            h: 1,
            fontSize: 14,
            color: '888888',
            align: 'center'
        });
    }

    /**
     * Create table of contents slide
     */
    private static createTableOfContentsSlide(pptx: any, slides: SlideContent[]): void {
        const slide = pptx.addSlide();
        
        // Title
        slide.addText('Table of Contents', {
            x: 1,
            y: 0.5,
            w: 11.33,
            h: 1,
            fontSize: 28,
            bold: true,
            color: '2F5597'
        });

        // Content items
        const tocItems = slides
            .filter(s => s.level <= 2)
            .map((s, index) => `${index + 1}. ${s.title}`)
            .slice(0, 10); // Limit to first 10 items

        slide.addText(tocItems, {
            x: 2,
            y: 2,
            w: 9.33,
            h: 4.5,
            fontSize: 16,
            bullet: { type: 'number' }
        });
    }

    /**
     * Create content slide
     */
    private static createContentSlide(pptx: any, slideContent: SlideContent): void {
        const slide = pptx.addSlide();
        
        // Title
        slide.addText(slideContent.title, {
            x: 0.5,
            y: 0.3,
            w: 12.33,
            h: 0.8,
            fontSize: 24,
            bold: true,
            color: '2F5597'
        });

        let yPosition = 1.3;
        const maxY = 6.5;

        for (const item of slideContent.content) {
            if (yPosition >= maxY) break;

            switch (item.type) {
                case 'bullet':
                    slide.addText(item.text, {
                        x: 1,
                        y: yPosition,
                        w: 11.33,
                        h: 0.4,
                        fontSize: 14,
                        bullet: item.numbered ? { type: 'number' } : true,
                        indentLevel: (item.level || 1) - 1
                    });
                    yPosition += 0.4;
                    break;

                case 'text':
                    slide.addText(item.text, {
                        x: 1,
                        y: yPosition,
                        w: 11.33,
                        h: 0.4,
                        fontSize: 14
                    });
                    yPosition += 0.4;
                    break;

                case 'table':
                    if (item.data && item.data.length > 0) {
                        const tableData = item.data.map(row => 
                            row.map(cell => ({ 
                                text: cell, 
                                options: { fontSize: 12 } 
                            }))
                        );

                        slide.addTable(tableData, {
                            x: 1,
                            y: yPosition,
                            w: 11.33,
                            colW: Array(item.data[0].length).fill(11.33 / item.data[0].length)
                        });
                        yPosition += Math.min(2, item.data.length * 0.3 + 0.5);
                    }
                    break;
            }
        }
    }

    /**
     * Generate multiple PowerPoint presentations from a directory of markdown files
     */
    static async generatePresentationsFromDirectory(
        inputDir: string,
        outputDir: string,
        options: Partial<PptxOptions> = {}
    ): Promise<void> {
        try {
            // Ensure output directory exists
            await fs.mkdir(outputDir, { recursive: true });

            // Get all markdown files
            const files = await fs.readdir(inputDir, { recursive: true });
            const markdownFiles = files.filter(file => 
                typeof file === 'string' && file.endsWith('.md')
            ) as string[];

            console.log(`📊 Converting ${markdownFiles.length} markdown files to PowerPoint presentations...`);

            for (const file of markdownFiles) {
                const inputPath = path.join(inputDir, file);
                const outputPath = path.join(outputDir, file.replace('.md', '.pptx'));
                
                // Ensure subdirectory exists
                await fs.mkdir(path.dirname(outputPath), { recursive: true });

                try {
                    const content = await fs.readFile(inputPath, 'utf-8');
                    const title = this.extractTitleFromMarkdown(content) || path.basename(file, '.md');
                    
                    await this.generatePresentation(content, outputPath, {
                        title,
                        author: options.author,
                        company: options.company,
                        description: options.description,
                        theme: options.theme,
                        includeTOC: options.includeTOC
                    });
                } catch (error: any) {
                    console.error(`❌ Failed to convert ${file}: ${error.message}`);
                }
            }

            console.log(`✅ PowerPoint conversion completed! Check ${outputDir}/`);
        } catch (error: any) {
            console.error(`❌ Failed to convert directory: ${error.message}`);
            throw error;
        }
    }

    /**
     * Extract title from markdown content
     */
    private static extractTitleFromMarkdown(content: string): string | null {
        const lines = content.split('\n');
        for (const line of lines) {
            if (line.startsWith('# ')) {
                return line.replace('# ', '').trim();
            }
        }
        return null;
    }
}

/**
 * Interface for slide content structure
 */
interface SlideContent {
    title: string;
    level: number;
    content: SlideContentItem[];
}

interface SlideContentItem {
    type: 'bullet' | 'text' | 'table';
    text?: string;
    data?: string[][];
    level?: number;
    numbered?: boolean;
}
