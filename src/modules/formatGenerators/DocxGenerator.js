/**
 * Word Document (.docx) Generator Module for Requirements Gathering Agent
 *
 * Converts markdown content to professionally formatted Word documents using the 'docx' library.
 * Provides enterprise-friendly document output for all supported document types.
 *
 * @version 1.0.0
 * @author Requirements Gathering Agent Team
 * @created December 2024
 *
 * Key Features:
 * - Native Word document generation from markdown content
 * - Professional formatting with consistent styling
 * - Support for headings, paragraphs, lists, and tables
 * - Document metadata and properties
 * - Enterprise-ready document structure
 *
 * @filepath c:\Users\menno\Source\Repos\requirements-gathering-agent\src\modules\formatGenerators\DocxGenerator.ts
 */
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } from 'docx';
import * as fs from 'fs/promises';
import * as path from 'path';
/**
 * Class responsible for generating Word documents from markdown content
 */
export class DocxGenerator {
    options;
    constructor(options) {
        this.options = {
            title: options.title,
            author: options.author || 'Requirements Gathering Agent',
            description: options.description || 'Generated project documentation',
            timestamp: options.timestamp || new Date(),
            projectName: options.projectName || 'Project',
            category: options.category || 'Documentation'
        };
    }
    /**
     * Convert markdown content to Word document
     * @param markdownContent The markdown content to convert
     * @returns Promise<Buffer> The generated Word document as buffer
     */
    async generateDocument(markdownContent) {
        const paragraphs = this.parseMarkdownToParagraphs(markdownContent);
        const doc = new Document({
            creator: this.options.author,
            title: this.options.title,
            description: this.options.description,
            lastModifiedBy: this.options.author,
            revision: 1,
            sections: [{
                    properties: {},
                    children: [
                        // Document header
                        ...this.createDocumentHeader(),
                        // Empty line
                        new Paragraph({
                            children: [new TextRun('')],
                        }),
                        // Converted content
                        ...paragraphs
                    ]
                }]
        });
        return await Packer.toBuffer(doc);
    } /**
     * Save Word document to file
     * @param markdownContent The markdown content to convert
     * @param outputPath The output file path
     */
    async saveDocument(markdownContent, outputPath) {
        try {
            console.log(`üìÑ Converting to Word document: ${path.basename(outputPath)}`);
            const buffer = await this.generateDocument(markdownContent);
            // Ensure directory exists
            const dir = path.dirname(outputPath);
            await fs.mkdir(dir, { recursive: true });
            // Save the document
            await fs.writeFile(outputPath, buffer);
            // Success message with file size
            const stats = await fs.stat(outputPath);
            const fileSizeKB = Math.round(stats.size / 1024);
            console.log(`‚úÖ Word document saved: ${outputPath} (${fileSizeKB} KB)`);
        }
        catch (error) {
            console.error(`‚ùå Failed to save Word document: ${error.message}`);
            throw error;
        }
    }
    /**
     * Create document header with metadata
     */
    createDocumentHeader() {
        return [
            // Main title
            new Paragraph({
                children: [
                    new TextRun({
                        text: this.options.title,
                        bold: true,
                        size: 32, // 16pt font
                        font: 'Calibri'
                    })
                ],
                heading: HeadingLevel.TITLE,
                alignment: AlignmentType.CENTER,
                spacing: { after: 400 }
            }),
            // Metadata section
            new Paragraph({
                children: [
                    new TextRun({
                        text: 'Generated by: ',
                        bold: true,
                        size: 20
                    }),
                    new TextRun({
                        text: this.options.author,
                        size: 20
                    })
                ],
                spacing: { after: 200 }
            }),
            new Paragraph({
                children: [
                    new TextRun({
                        text: 'Project: ',
                        bold: true,
                        size: 20
                    }),
                    new TextRun({
                        text: this.options.projectName,
                        size: 20
                    })
                ],
                spacing: { after: 200 }
            }),
            new Paragraph({
                children: [
                    new TextRun({
                        text: 'Category: ',
                        bold: true,
                        size: 20
                    }),
                    new TextRun({
                        text: this.options.category,
                        size: 20
                    })
                ],
                spacing: { after: 200 }
            }),
            new Paragraph({
                children: [
                    new TextRun({
                        text: 'Generated: ',
                        bold: true,
                        size: 20
                    }),
                    new TextRun({
                        text: this.options.timestamp.toLocaleString(),
                        size: 20
                    })
                ],
                spacing: { after: 400 }
            }),
            // Horizontal line (using underlined text)
            new Paragraph({
                children: [
                    new TextRun({
                        text: '‚îÄ'.repeat(50),
                        size: 20,
                        color: '999999'
                    })
                ],
                spacing: { after: 400 }
            })
        ];
    }
    /**
     * Parse markdown content into Word document paragraphs
     */
    parseMarkdownToParagraphs(markdown) {
        const lines = markdown.split('\n');
        const paragraphs = [];
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            // Skip empty lines (they'll be handled as spacing)
            if (line.trim() === '') {
                continue;
            }
            // Handle different markdown elements
            if (line.startsWith('# ')) {
                paragraphs.push(this.createHeading(line.substring(2), HeadingLevel.HEADING_1));
            }
            else if (line.startsWith('## ')) {
                paragraphs.push(this.createHeading(line.substring(3), HeadingLevel.HEADING_2));
            }
            else if (line.startsWith('### ')) {
                paragraphs.push(this.createHeading(line.substring(4), HeadingLevel.HEADING_3));
            }
            else if (line.startsWith('#### ')) {
                paragraphs.push(this.createHeading(line.substring(5), HeadingLevel.HEADING_4));
            }
            else if (line.startsWith('- ') || line.startsWith('* ')) {
                paragraphs.push(this.createBulletPoint(line.substring(2)));
            }
            else if (/^\d+\.\s/.test(line)) {
                // Numbered list item
                const match = line.match(/^\d+\.\s(.+)$/);
                if (match) {
                    paragraphs.push(this.createNumberedPoint(match[1]));
                }
            }
            else if (line.startsWith('**') && line.endsWith('**')) {
                // Bold paragraph (often used for metadata)
                paragraphs.push(this.createBoldParagraph(line.substring(2, line.length - 2)));
            }
            else if (line.startsWith('---')) {
                // Horizontal rule - skip for now, as we handle it in header
                continue;
            }
            else {
                // Regular paragraph
                paragraphs.push(this.createParagraph(line));
            }
        }
        return paragraphs;
    } /**
     * Create a heading paragraph
     */
    createHeading(text, level) {
        const fontSizes = {
            [HeadingLevel.HEADING_1]: 28, // 14pt
            [HeadingLevel.HEADING_2]: 26, // 13pt
            [HeadingLevel.HEADING_3]: 24, // 12pt
            [HeadingLevel.HEADING_4]: 22, // 11pt
        };
        return new Paragraph({
            children: [
                new TextRun({
                    text: text.trim(),
                    bold: true,
                    size: fontSizes[level] || 24,
                    font: 'Calibri'
                })
            ],
            heading: level,
            spacing: {
                before: level === HeadingLevel.HEADING_1 ? 400 : 300,
                after: 200
            }
        });
    }
    /**
     * Create a bullet point paragraph
     */
    createBulletPoint(text) {
        return new Paragraph({
            children: [
                new TextRun({
                    text: `‚Ä¢ ${text.trim()}`,
                    size: 22, // 11pt
                    font: 'Calibri'
                })
            ],
            spacing: { after: 100 },
            indent: { left: 360 } // 0.25 inch indent
        });
    }
    /**
     * Create a numbered point paragraph
     */
    createNumberedPoint(text) {
        return new Paragraph({
            children: [
                new TextRun({
                    text: text.trim(),
                    size: 22, // 11pt
                    font: 'Calibri'
                })
            ],
            spacing: { after: 100 },
            indent: { left: 360 } // 0.25 inch indent
        });
    }
    /**
     * Create a bold paragraph (for metadata or emphasis)
     */
    createBoldParagraph(text) {
        return new Paragraph({
            children: [
                new TextRun({
                    text: text.trim(),
                    bold: true,
                    size: 22, // 11pt
                    font: 'Calibri'
                })
            ],
            spacing: { after: 200 }
        });
    }
    /**
     * Create a regular paragraph
     */
    createParagraph(text) {
        return new Paragraph({
            children: [
                new TextRun({
                    text: text.trim(),
                    size: 22, // 11pt
                    font: 'Calibri'
                })
            ],
            spacing: { after: 200 }
        });
    }
}
/**
 * Version information
 */
export const docxGeneratorVersion = '1.0.0';
