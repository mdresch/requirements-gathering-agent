/**
 * Word Document (.docx) Generator Module for Requirements Gathering Agent
 * 
 * Converts markdown content to professionally formatted Word documents using the 'docx' library.
 * Provides enterprise-friendly document output for all supported document types.
 * 
 * @version 1.0.0
 * @author Requirements Gathering Agent Team
 * @created December 2024
 * 
 * Key Features:
 * - Native Word document generation from markdown content
 * - Professional formatting with consistent styling
 * - Support for headings, paragraphs, lists, and tables
 * - Document metadata and properties
 * - Enterprise-ready document structure
 * 
 * @filepath c:\Users\menno\Source\Repos\requirements-gathering-agent\src\modules\formatGenerators\DocxGenerator.ts
 */

import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, UnderlineType, Table, TableRow, TableCell, WidthType, BorderStyle } from 'docx';
import * as fs from 'fs/promises';
import * as path from 'path';

export interface DocxGeneratorOptions {
    /** Document title */
    title: string;
    /** Document author */
    author?: string;
    /** Document description */
    description?: string;
    /** Generated timestamp */
    timestamp?: Date;
    /** Project name */
    projectName?: string;
    /** Document category */
    category?: string;
}

/**
 * Class responsible for generating Word documents from markdown content
 */
export class DocxGenerator {
    private options: Required<DocxGeneratorOptions>;

    constructor(options: DocxGeneratorOptions) {
        this.options = {
            title: options.title,
            author: options.author || 'Requirements Gathering Agent',
            description: options.description || 'Generated project documentation',
            timestamp: options.timestamp || new Date(),
            projectName: options.projectName || 'Project',
            category: options.category || 'Documentation'        };
    }

    /**
     * Convert markdown content to Word document
     * @param markdownContent The markdown content to convert
     * @returns Promise<Buffer> The generated Word document as buffer
     */
    public async generateDocument(markdownContent: string): Promise<Buffer> {
        const elements = this.parseMarkdownToElements(markdownContent);
        
        const doc = new Document({
            creator: this.options.author,
            title: this.options.title,
            description: this.options.description,
            lastModifiedBy: this.options.author,
            revision: 1,
            sections: [{
                properties: {},
                children: [
                    // Document header
                    ...this.createDocumentHeader(),
                    // Empty line
                    new Paragraph({
                        children: [new TextRun('')],
                    }),
                    // Converted content
                    ...elements
                ]
            }]
        });        return await Packer.toBuffer(doc);
    }

    /**
     * Save Word document to file
     * @param markdownContent The markdown content to convert
     * @param outputPath The output file path
     */
    public async saveDocument(markdownContent: string, outputPath: string): Promise<void> {
        try {
            console.log(`üìÑ Converting to Word document: ${path.basename(outputPath)}`);
            
            const buffer = await this.generateDocument(markdownContent);
            
            // Ensure directory exists
            const dir = path.dirname(outputPath);
            await fs.mkdir(dir, { recursive: true });
            
            // Save the document
            await fs.writeFile(outputPath, buffer);
            
            // Success message with file size
            const stats = await fs.stat(outputPath);
            const fileSizeKB = Math.round(stats.size / 1024);
            console.log(`‚úÖ Word document saved: ${outputPath} (${fileSizeKB} KB)`);
            
        } catch (error: any) {
            console.error(`‚ùå Failed to save Word document: ${error.message}`);
            throw error;
        }
    }

    /**
     * Create document header with metadata
     */
    private createDocumentHeader(): Paragraph[] {
        return [
            // Main title
            new Paragraph({
                children: [
                    new TextRun({
                        text: this.options.title,
                        bold: true,
                        size: 32, // 16pt font
                        font: 'Calibri'
                    })
                ],
                heading: HeadingLevel.TITLE,
                alignment: AlignmentType.CENTER,
                spacing: { after: 400 }
            }),

            // Metadata section
            new Paragraph({
                children: [
                    new TextRun({
                        text: 'Generated by: ',
                        bold: true,
                        size: 20
                    }),
                    new TextRun({
                        text: this.options.author,
                        size: 20
                    })
                ],
                spacing: { after: 200 }
            }),

            new Paragraph({
                children: [
                    new TextRun({
                        text: 'Project: ',
                        bold: true,
                        size: 20
                    }),
                    new TextRun({
                        text: this.options.projectName,
                        size: 20
                    })
                ],
                spacing: { after: 200 }
            }),

            new Paragraph({
                children: [
                    new TextRun({
                        text: 'Category: ',
                        bold: true,
                        size: 20
                    }),
                    new TextRun({
                        text: this.options.category,
                        size: 20
                    })
                ],
                spacing: { after: 200 }
            }),

            new Paragraph({
                children: [
                    new TextRun({
                        text: 'Generated: ',
                        bold: true,
                        size: 20
                    }),
                    new TextRun({
                        text: this.options.timestamp.toLocaleString(),
                        size: 20
                    })
                ],
                spacing: { after: 400 }
            }),

            // Horizontal line (using underlined text)
            new Paragraph({
                children: [
                    new TextRun({
                        text: '‚îÄ'.repeat(50),
                        size: 20,
                        color: '999999'
                    })
                ],
                spacing: { after: 400 }
            })        ];
    }

    /**
     * Parse markdown content into Word document elements (paragraphs and tables)
     */
    private parseMarkdownToElements(markdown: string): (Paragraph | Table)[] {
        const lines = markdown.split('\n');
        const elements: (Paragraph | Table)[] = [];
        let i = 0;        while (i < lines.length) {
            const line = lines[i];
            
            // Skip empty lines (they'll be handled as spacing)
            if (line.trim() === '') {
                i++;
                continue;
            }

            // Handle different markdown elements
            if (line.startsWith('# ')) {
                elements.push(this.createHeading(line.substring(2), HeadingLevel.HEADING_1));
            } else if (line.startsWith('## ')) {
                elements.push(this.createHeading(line.substring(3), HeadingLevel.HEADING_2));
            } else if (line.startsWith('### ')) {
                elements.push(this.createHeading(line.substring(4), HeadingLevel.HEADING_3));
            } else if (line.startsWith('#### ')) {
                elements.push(this.createHeading(line.substring(5), HeadingLevel.HEADING_4));
            } else if (line.startsWith('- ') || line.startsWith('* ')) {
                elements.push(this.createBulletPoint(line.substring(2)));
            } else if (/^\d+\.\s/.test(line)) {
                // Numbered list item
                const match = line.match(/^\d+\.\s(.+)$/);
                if (match) {
                    elements.push(this.createNumberedPoint(match[1]));
                }
            } else if (line.trim().startsWith('|') && line.trim().endsWith('|')) {
                // Table detected - parse the entire table
                const tableResult = this.parseTable(lines, i);
                if (tableResult.table) {
                    elements.push(tableResult.table);
                }
                i = tableResult.nextIndex - 1; // -1 because the loop will increment            } else if (line.startsWith('---')) {
                // Horizontal rule - skip for now, as we handle it in header
                // Add a spacing paragraph instead
                elements.push(new Paragraph({
                    children: [new TextRun('')],
                    spacing: { after: 200 }
                }));
            } else {
                // Regular paragraph with inline formatting support
                elements.push(this.createParagraphWithInlineFormatting(line));
            }
            i++;
        }

        return elements;
    }

    /**
     * Parse a table from markdown format
     */
    private parseTable(lines: string[], startIndex: number): { table: Table | null, nextIndex: number } {
        const tableLines: string[] = [];
        let i = startIndex;
        
        // Collect all table lines
        while (i < lines.length && lines[i].trim().startsWith('|') && lines[i].trim().endsWith('|')) {
            tableLines.push(lines[i]);
            i++;
        }
        
        // Need at least 2 lines (header + separator or header + data)
        if (tableLines.length < 2) {
            return { table: null, nextIndex: startIndex + 1 };
        }
        
        // Parse header row
        const headerRow = this.parseTableRow(tableLines[0]);
        if (!headerRow.length) {
            return { table: null, nextIndex: startIndex + 1 };
        }
        
        // Check if second line is separator (|---|---|)
        const separatorIndex = tableLines[1].includes('---') ? 1 : -1;
        const dataStartIndex = separatorIndex >= 0 ? 2 : 1;
        
        // Parse data rows
        const dataRows: string[][] = [];
        for (let j = dataStartIndex; j < tableLines.length; j++) {
            const row = this.parseTableRow(tableLines[j]);
            if (row.length) {
                dataRows.push(row);
            }
        }
        
        // Create Word table
        const table = this.createWordTable(headerRow, dataRows);
        return { table, nextIndex: i };
    }
    
    /**
     * Parse a single table row from markdown
     */
    private parseTableRow(line: string): string[] {
        // Remove leading and trailing |, then split by |
        const cleaned = line.trim().slice(1, -1);
        return cleaned.split('|').map(cell => cell.trim());
    }
      /**
     * Create a Word table from header and data rows
     */
    private createWordTable(headerRow: string[], dataRows: string[][]): Table {
        const rows: TableRow[] = [];
        
        // Create header row
        const headerCells = headerRow.map(cellText => 
            new TableCell({
                children: [
                    new Paragraph({
                        children: [
                            new TextRun({
                                text: cellText,
                                bold: true,
                                size: 22,
                                font: 'Calibri'
                            })
                        ],
                        alignment: AlignmentType.CENTER
                    })
                ],
                width: { size: 100 / headerRow.length, type: WidthType.PERCENTAGE }
            })
        );
        
        rows.push(new TableRow({
            children: headerCells
        }));
        
        // Create data rows
        dataRows.forEach(dataRow => {
            const dataCells = dataRow.map(cellText => 
                new TableCell({
                    children: [
                        new Paragraph({
                            children: [
                                new TextRun({
                                    text: cellText,
                                    size: 22,
                                    font: 'Calibri'
                                })
                            ]
                        })
                    ],
                    width: { size: 100 / headerRow.length, type: WidthType.PERCENTAGE }
                })
            );
            
            rows.push(new TableRow({
                children: dataCells
            }));
        });
        
        const table = new Table({
            rows: rows,
            width: { size: 100, type: WidthType.PERCENTAGE },
            borders: {
                top: { style: BorderStyle.SINGLE, size: 1 },
                bottom: { style: BorderStyle.SINGLE, size: 1 },
                left: { style: BorderStyle.SINGLE, size: 1 },
                right: { style: BorderStyle.SINGLE, size: 1 },
                insideHorizontal: { style: BorderStyle.SINGLE, size: 1 },
                insideVertical: { style: BorderStyle.SINGLE, size: 1 }
            }
        });
        
        return table;
    }
    
    /**
     * Create a paragraph with inline formatting support (bold, italic)
     */
    private createParagraphWithInlineFormatting(text: string): Paragraph {
        const textRuns = this.parseInlineFormatting(text);
        
        return new Paragraph({
            children: textRuns,
            spacing: { after: 200 }
        });
    }
      /**
     * Parse inline formatting like **bold** and *italic* within text
     */
    private parseInlineFormatting(text: string): TextRun[] {
        const runs: TextRun[] = [];
          // Regular expressions for different formatting (non-global for better control)
        const patterns = [
            { regex: /\*\*\*(.*?)\*\*\*/g, bold: true, italic: true },  // ***bold italic***
            { regex: /\*\*(.*?)\*\*/g, bold: true, italic: false },     // **bold**
            { regex: /\*(.*?)\*/g, bold: false, italic: true },         // *italic*
            { regex: /`(.*?)`/g, bold: false, italic: false, code: true } // `code`
        ];
        
        // Find all formatting matches
        const matches: Array<{
            start: number;
            end: number;
            text: string;
            bold: boolean;
            italic: boolean;
            code?: boolean;
        }> = [];
        
        // Reset regex state and find matches
        patterns.forEach(pattern => {
            pattern.regex.lastIndex = 0; // Reset global regex state
            let match;
            while ((match = pattern.regex.exec(text)) !== null) {
                matches.push({
                    start: match.index,
                    end: match.index + match[0].length,
                    text: match[1], // The captured group (text without markers)
                    bold: pattern.bold,
                    italic: pattern.italic,
                    code: pattern.code || false                });
                
                // Prevent infinite loop with global regex
                if (pattern.regex.lastIndex === match.index) {
                    pattern.regex.lastIndex++;
                }
            }
        });
        
        // Sort matches by start position
                    end: match.index + match[0].length,
                    text: match[1], // The captured group (text without markers)
                    bold: pattern.bold,
                    italic: pattern.italic,
                    code: pattern.code || false
                });
                
                // Prevent infinite loop with global regex
                if (pattern.regex.lastIndex === match.index) {
                    pattern.regex.lastIndex++;
                }
            }
        });
        
        // Sort matches by start position
        matches.sort((a, b) => a.start - b.start);
        
        // Remove overlapping matches (keep the first one found)
        const filteredMatches = [];
        let lastEnd = -1;
        for (const match of matches) {
            if (match.start >= lastEnd) {
                filteredMatches.push(match);
                lastEnd = match.end;
            }
        }
        
        // Build text runs
        let lastIndex = 0;
        
        filteredMatches.forEach(match => {
            // Add text before the match
            if (match.start > lastIndex) {
                const beforeText = text.substring(lastIndex, match.start);
                if (beforeText) {
                    runs.push(new TextRun({
                        text: beforeText,
                        size: 22,
                        font: 'Calibri'
                    }));
                }
            }
            
            // Add the formatted text
            runs.push(new TextRun({
                text: match.text,
                bold: match.bold,
                italics: match.italic,
                size: 22,
                font: match.code ? 'Consolas' : 'Calibri'
            }));
            
            lastIndex = match.end;
        });
        
        // Add remaining text after the last match
        if (lastIndex < text.length) {
            const remainingText = text.substring(lastIndex);
            if (remainingText) {
                runs.push(new TextRun({
                    text: remainingText,
                    size: 22,
                    font: 'Calibri'
                }));
            }
        }
        
        // If no formatting was found, return the original text
        if (runs.length === 0) {
            runs.push(new TextRun({
                text: text.trim(),
                size: 22,
                font: 'Calibri'
            }));
        }
        
        return runs;
    }

    /**
     * Create a heading paragraph
     */
    private createHeading(text: string, level: typeof HeadingLevel[keyof typeof HeadingLevel]): Paragraph {
        const fontSizes: Record<string, number> = {
            [HeadingLevel.HEADING_1]: 28, // 14pt
            [HeadingLevel.HEADING_2]: 26, // 13pt
            [HeadingLevel.HEADING_3]: 24, // 12pt
            [HeadingLevel.HEADING_4]: 22, // 11pt
        };

        // Parse inline formatting but make all heading text bold
        const textRuns = this.parseInlineFormatting(text.trim()).map(run => 
            new TextRun({
                ...run,
                bold: true, // Force all heading text to be bold
                size: fontSizes[level] || 24,
                font: 'Calibri'
            })
        );

        return new Paragraph({
            children: textRuns,
            heading: level,
            spacing: { 
                before: level === HeadingLevel.HEADING_1 ? 400 : 300,
                after: 200 
            }
        });
    }/**
     * Create a bullet point paragraph
     */
    private createBulletPoint(text: string): Paragraph {
        const textRuns = this.parseInlineFormatting(text.trim());
        
        return new Paragraph({
            children: [
                new TextRun({
                    text: '‚Ä¢ ',
                    size: 22,
                    font: 'Calibri'
                }),
                ...textRuns
            ],
            spacing: { after: 100 },
            indent: { left: 360 } // 0.25 inch indent
        });
    }    /**
     * Create a numbered point paragraph
     */
    private createNumberedPoint(text: string): Paragraph {
        const textRuns = this.parseInlineFormatting(text.trim());
        
        return new Paragraph({
            children: textRuns,
            spacing: { after: 100 },
            indent: { left: 360 } // 0.25 inch indent
        });
    }

    /**
     * Create a bold paragraph (for metadata or emphasis)
     */
    private createBoldParagraph(text: string): Paragraph {
        return new Paragraph({
            children: [
                new TextRun({
                    text: text.trim(),
                    bold: true,
                    size: 22, // 11pt
                    font: 'Calibri'
                })
            ],
            spacing: { after: 200 }
        });
    }

    /**
     * Create a regular paragraph
     */
    private createParagraph(text: string): Paragraph {
        return new Paragraph({
            children: [
                new TextRun({
                    text: text.trim(),
                    size: 22, // 11pt
                    font: 'Calibri'
                })
            ],
            spacing: { after: 200 }
        });
    }
}

/**
 * Version information
 */
export const docxGeneratorVersion = '1.0.0';
