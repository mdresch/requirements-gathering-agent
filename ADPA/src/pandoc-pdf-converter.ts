/*
 * Pandoc-based Markdown to PDF Converter for ADPA
 * Uses your existing Pandoc installation for professional PDF generation
 */

import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';

interface ConversionResult {
  success: boolean;
  inputFile: string;
  outputFile: string;
  error?: string;
}

/**
 * Professional Pandoc PDF Converter
 */
export class PandocPDFConverter {
  private generatedDocsPath: string;
  private outputPath: string;

  constructor(generatedDocsPath: string, outputPath: string = './pdf-output') {
    this.generatedDocsPath = generatedDocsPath;
    this.outputPath = outputPath;
    
    // Create output directory if it doesn't exist
    if (!fs.existsSync(this.outputPath)) {
      fs.mkdirSync(this.outputPath, { recursive: true });
    }
  }

  /**
   * Convert a single markdown file to PDF using Pandoc
   */
  async convertMarkdownToPDF(markdownFile: string): Promise<ConversionResult> {
    try {
      const inputPath = path.resolve(markdownFile);
      const fileName = path.basename(markdownFile, '.md');
      const outputFile = path.join(this.outputPath, `${fileName}.pdf`);
      
      console.log(`Converting: ${markdownFile} ‚Üí ${outputFile}`);

      // Professional Pandoc command with PMBOK-style formatting
      const pandocCommand = [
        'pandoc',
        `"${inputPath}"`,
        '-o', `"${outputFile}"`,
        '--pdf-engine=xelatex',
        '--template=eisvogel',
        '--listings',
        '--number-sections',
        '--toc',
        '--toc-depth=3',
        '-V', 'geometry:margin=1in',
        '-V', 'fontsize=11pt',
        '-V', 'documentclass=article',
        '-V', 'papersize=a4',
        '-V', 'colorlinks=true',
        '-V', 'linkcolor=blue',
        '-V', 'urlcolor=blue',
        '-V', 'toccolor=black',
        '-V', 'title-meta="ADPA Generated Document"',
        '-V', 'author-meta="Automated Documentation Project Assistant"',
        '-V', `date-meta="${new Date().toLocaleDateString()}"`,
        '--highlight-style=github'
      ].join(' ');

      // Execute Pandoc conversion
      execSync(pandocCommand, { 
        stdio: 'pipe',
        cwd: process.cwd(),
        timeout: 60000 // 1 minute timeout
      });

      return {
        success: true,
        inputFile: markdownFile,
        outputFile: outputFile
      };

    } catch (error) {
      console.error(`Failed to convert ${markdownFile}:`, error);
      return {
        success: false,
        inputFile: markdownFile,
        outputFile: '',
        error: error.toString()
      };
    }
  }

  /**
   * Convert a single markdown file with enhanced PMBOK styling
   */
  async convertWithPMBOKStyling(markdownFile: string): Promise<ConversionResult> {
    try {
      const inputPath = path.resolve(markdownFile);
      const fileName = path.basename(markdownFile, '.md');
      const outputFile = path.join(this.outputPath, `${fileName}-PMBOK.pdf`);
      
      console.log(`Converting with PMBOK styling: ${markdownFile} ‚Üí ${outputFile}`);

      // Enhanced PMBOK-style command
      const pandocCommand = [
        'pandoc',
        `"${inputPath}"`,
        '-o', `"${outputFile}"`,
        '--pdf-engine=xelatex',
        '--number-sections',
        '--toc',
        '--toc-depth=2',
        '-V', 'geometry:margin=1.25in',
        '-V', 'fontsize=12pt',
        '-V', 'documentclass=report',
        '-V', 'papersize=letter',
        '-V', 'colorlinks=true',
        '-V', 'linkcolor=darkblue',
        '-V', 'toccolor=black',
        '-V', 'mainfont="Times New Roman"',
        '-V', 'sansfont="Arial"',
        '-V', 'monofont="Courier New"',
        '-V', 'title="Project Management Document"',
        '-V', 'subtitle="Generated by ADPA"',
        '-V', `date="${new Date().toLocaleDateString()}"`,
        '-V', 'author="Automated Documentation Project Assistant"',
        '--highlight-style=tango',
        '--filter=pandoc-crossref'
      ].join(' ');

      execSync(pandocCommand, { 
        stdio: 'pipe',
        cwd: process.cwd(),
        timeout: 60000
      });

      return {
        success: true,
        inputFile: markdownFile,
        outputFile: outputFile
      };

    } catch (error) {
      console.error(`Failed to convert ${markdownFile} with PMBOK styling:`, error);
      
      // Fallback to basic conversion if PMBOK styling fails
      console.log('Falling back to basic conversion...');
      return await this.convertMarkdownToPDF(markdownFile);
    }
  }

  /**
   * Find all markdown files in the generated-documents directory
   */
  findMarkdownFiles(): string[] {
    const markdownFiles: string[] = [];

    const scanDirectory = (dir: string) => {
      const items = fs.readdirSync(dir);
      
      for (const item of items) {
        const itemPath = path.join(dir, item);
        const stat = fs.statSync(itemPath);
        
        if (stat.isDirectory()) {
          scanDirectory(itemPath);
        } else if (item.endsWith('.md')) {
          markdownFiles.push(itemPath);
        }
      }
    };

    if (fs.existsSync(this.generatedDocsPath)) {
      scanDirectory(this.generatedDocsPath);
    }

    return markdownFiles;
  }

  /**
   * Convert all markdown files to PDF
   */
  async convertAllMarkdownFiles(): Promise<ConversionResult[]> {
    const markdownFiles = this.findMarkdownFiles();
    const results: ConversionResult[] = [];

    console.log(`Found ${markdownFiles.length} markdown files to convert`);

    for (const file of markdownFiles) {
      const result = await this.convertWithPMBOKStyling(file);
      results.push(result);
      
      // Small delay between conversions
      await new Promise(resolve => setTimeout(resolve, 500));
    }

    return results;
  }

  /**
   * Print conversion summary
   */
  printSummary(results: ConversionResult[]): void {
    const successful = results.filter(r => r.success);
    const failed = results.filter(r => !r.success);

    console.log('\n=== CONVERSION SUMMARY ===');
    console.log(`‚úÖ Successful: ${successful.length}`);
    console.log(`‚ùå Failed: ${failed.length}`);
    console.log(`üìÅ Output directory: ${this.outputPath}`);

    if (successful.length > 0) {
      console.log('\nüìÑ Successfully converted:');
      successful.forEach(result => {
        console.log(`  ‚Ä¢ ${path.basename(result.inputFile)} ‚Üí ${path.basename(result.outputFile)}`);
      });
    }

    if (failed.length > 0) {
      console.log('\n‚ö†Ô∏è  Failed conversions:');
      failed.forEach(result => {
        console.log(`  ‚Ä¢ ${path.basename(result.inputFile)}: ${result.error}`);
      });
    }
  }
}

/**
 * Main execution function
 */
async function main() {
  try {
    console.log('üöÄ ADPA Pandoc PDF Converter Starting...\n');

    // Initialize converter
    const generatedDocsPath = path.resolve('../generated-documents');
    const converter = new PandocPDFConverter(generatedDocsPath);

    // Check if Pandoc is available
    try {
      execSync('pandoc --version', { stdio: 'pipe' });
      console.log('‚úÖ Pandoc found and ready');
    } catch (error) {
      throw new Error('Pandoc not found. Please install Pandoc first.');
    }

    // Convert all markdown files
    const results = await converter.convertAllMarkdownFiles();

    // Print summary
    converter.printSummary(results);

    console.log('\nüéâ Conversion completed!');

  } catch (error) {
    console.error('‚ùå Conversion failed:', error);
    process.exit(1);
  }
}

// Run if this file is executed directly
if (require.main === module) {
  main();
}

export { PandocPDFConverter };
