#!/usr/bin/env node

/**
 * Reliable Puppeteer-Based PDF Conversion for Generated Documents
 * 
 * This script provides a simplified, reliable PDF conversion solution
 * using only Puppeteer for consistent results.
 */

import { promises as fs } from 'fs';
import path from 'path';
import { marked } from 'marked';
import puppeteer from 'puppeteer';

// Configuration
const CONFIG = {
    inputDir: './generated-documents',
    outputDir: './generated-documents-pdf',
    supportedExtensions: ['.md', '.txt', '.html'],
    concurrency: 2, // Process 2 files at once
    timeout: 60000, // 60 seconds per file
    retries: 2
};

// Logging
const log = (level, msg) => console.log(`[${level}] ${new Date().toISOString()} - ${msg}`);

// Professional HTML template
function createHTML(title, content, sourcePath) {
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2c3e50;
            margin: 0;
            padding: 40px;
            background: white;
        }
        .header {
            border-bottom: 3px solid #3498db;
            margin-bottom: 40px;
            padding-bottom: 20px;
        }
        .header h1 {
            color: #2c3e50;
            margin: 0 0 15px 0;
            font-size: 2.2em;
            font-weight: 300;
        }
        .meta {
            background: #f8f9fa;
            padding: 20px;
            border-left: 4px solid #3498db;
            margin-bottom: 30px;
            font-size: 0.9em;
            color: #666;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #2c3e50;
            margin-top: 30px;
            margin-bottom: 15px;
            line-height: 1.3;
        }
        h1 { font-size: 2em; border-bottom: 2px solid #ecf0f1; padding-bottom: 10px; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #ecf0f1; padding-bottom: 8px; }
        h3 { font-size: 1.3em; }
        h4 { font-size: 1.1em; }
        p { margin-bottom: 16px; text-align: justify; }
        code {
            background: #f1f2f6;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
        }
        pre {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 4px solid #3498db;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }
        blockquote {
            border-left: 4px solid #3498db;
            margin: 20px 0;
            padding: 10px 20px;
            background: #f8f9fa;
            font-style: italic;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px 15px;
            text-align: left;
        }
        th {
            background: #3498db;
            color: white;
            font-weight: 600;
        }
        tr:nth-child(even) { background: #f8f9fa; }
        ul, ol { padding-left: 25px; margin-bottom: 16px; }
        li { margin-bottom: 8px; }
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ecf0f1;
            text-align: center;
            font-size: 0.8em;
            color: #7f8c8d;
        }
        @page {
            margin: 1in;
            @top-center {
                content: "${title}";
                font-size: 10px;
                color: #666;
            }
            @bottom-center {
                content: counter(page) " of " counter(pages);
                font-size: 10px;
                color: #666;
            }
        }
        @media print {
            body { padding: 20px; }
            .header { margin-bottom: 30px; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>${title}</h1>
    </div>
    <div class="meta">
        <strong>Source File:</strong> ${sourcePath}<br>
        <strong>Generated:</strong> ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}<br>
        <strong>Generated by:</strong> Requirements Gathering Agent - PDF Converter
    </div>
    <div class="content">
        ${content}
    </div>
    <div class="footer">
        Generated from ${sourcePath} | Requirements Gathering Agent
    </div>
</body>
</html>`;
}

// Content processors
async function processMarkdown(filePath) {
    const content = await fs.readFile(filePath, 'utf-8');
    const title = path.basename(filePath, '.md')
        .replace(/[-_]/g, ' ')
        .replace(/\b\w/g, l => l.toUpperCase());
    
    const html = marked(content, {
        gfm: true,
        breaks: true,
        headerIds: false,
        mangle: false
    });
    
    return createHTML(title, html, filePath);
}

async function processText(filePath) {
    const content = await fs.readFile(filePath, 'utf-8');
    const title = path.basename(filePath, '.txt')
        .replace(/[-_]/g, ' ')
        .replace(/\b\w/g, l => l.toUpperCase());
    
    const htmlContent = content
        .split('\n')
        .map(line => {
            const trimmed = line.trim();
            return trimmed ? `<p>${trimmed}</p>` : '<p>&nbsp;</p>';
        })
        .join('\n');
    
    return createHTML(title, htmlContent, filePath);
}

async function processHTML(filePath) {
    return await fs.readFile(filePath, 'utf-8');
}

// File processors map
const processors = {
    '.md': processMarkdown,
    '.txt': processText,
    '.html': processHTML
};

// Convert single file to PDF
async function convertToPDF(filePath, outputPath, retryCount = 0) {
    let browser = null;
    
    try {
        // Get file extension and process content
        const ext = path.extname(filePath).toLowerCase();
        const processor = processors[ext];
        
        if (!processor) {
            throw new Error(`No processor for extension: ${ext}`);
        }
        
        // Process content to HTML
        const htmlContent = await processor(filePath);
        
        // Launch Puppeteer
        browser = await puppeteer.launch({
            headless: 'new',
            args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage',
                '--disable-web-security'
            ]
        });
        
        const page = await browser.newPage();
        
        // Set content and wait for it to load
        await page.setContent(htmlContent, {
            waitUntil: ['load', 'networkidle0'],
            timeout: CONFIG.timeout
        });
        
        // Generate PDF
        await page.pdf({
            path: outputPath,
            format: 'A4',
            margin: {
                top: '1in',
                right: '1in',
                bottom: '1in',
                left: '1in'
            },
            printBackground: true,
            preferCSSPageSize: false,
            displayHeaderFooter: false
        });
        
        return { success: true, retries: retryCount };
        
    } catch (error) {
        if (retryCount < CONFIG.retries) {
            log('WARN', `Retry ${retryCount + 1}/${CONFIG.retries} for ${filePath}: ${error.message}`);
            await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s before retry
            return await convertToPDF(filePath, outputPath, retryCount + 1);
        }
        throw error;
    } finally {
        if (browser) {
            await browser.close();
        }
    }
}

// Discover all files recursively
async function discoverFiles(dir) {
    const files = [];
    
    async function scan(currentDir) {
        const entries = await fs.readdir(currentDir, { withFileTypes: true });
        
        for (const entry of entries) {
            const fullPath = path.join(currentDir, entry.name);
            
            if (entry.isDirectory()) {
                await scan(fullPath);
            } else if (entry.isFile()) {
                const ext = path.extname(entry.name).toLowerCase();
                if (CONFIG.supportedExtensions.includes(ext)) {
                    files.push({
                        fullPath,
                        relativePath: path.relative(dir, fullPath),
                        extension: ext
                    });
                }
            }
        }
    }
    
    await scan(dir);
    return files;
}

// Process files in batches
async function processBatch(files, startIndex, batchSize) {
    const batch = files.slice(startIndex, startIndex + batchSize);
    const results = await Promise.allSettled(
        batch.map(async (file) => {
            const outputPath = path.join(
                CONFIG.outputDir,
                file.relativePath.replace(file.extension, '.pdf')
            );
            
            // Ensure output directory exists
            await fs.mkdir(path.dirname(outputPath), { recursive: true });
            
            // Check if already exists
            try {
                await fs.access(outputPath);
                log('INFO', `Skipping ${file.relativePath} - already exists`);
                return { file, skipped: true };
            } catch {
                // File doesn't exist, proceed
            }
            
            // Convert file
            const result = await convertToPDF(file.fullPath, outputPath);
            log('SUCCESS', `Converted ${file.relativePath} (${result.retries} retries)`);
            return { file, ...result };
        })
    );
    
    return results;
}

// Main function
async function main() {
    try {
        log('INFO', 'Starting batch PDF conversion...');
        
        // Ensure output directory exists
        await fs.mkdir(CONFIG.outputDir, { recursive: true });
        
        // Discover files
        log('INFO', `Scanning ${CONFIG.inputDir}...`);
        const files = await discoverFiles(CONFIG.inputDir);
        
        if (files.length === 0) {
            log('WARN', 'No files found to convert');
            return;
        }
        
        log('INFO', `Found ${files.length} files to convert`);
        
        // Show file breakdown
        const breakdown = files.reduce((acc, file) => {
            acc[file.extension] = (acc[file.extension] || 0) + 1;
            return acc;
        }, {});
        
        Object.entries(breakdown).forEach(([ext, count]) => {
            log('INFO', `  ${ext}: ${count} files`);
        });
        
        // Process files in batches
        const results = {
            total: files.length,
            converted: 0,
            skipped: 0,
            failed: 0,
            errors: []
        };
        
        const startTime = Date.now();
        
        for (let i = 0; i < files.length; i += CONFIG.concurrency) {
            const batchResults = await processBatch(files, i, CONFIG.concurrency);
            
            batchResults.forEach((result, index) => {
                if (result.status === 'fulfilled') {
                    if (result.value.skipped) {
                        results.skipped++;
                    } else {
                        results.converted++;
                    }
                } else {
                    results.failed++;
                    const file = files[i + index];
                    results.errors.push({
                        file: file.relativePath,
                        error: result.reason.message
                    });
                    log('ERROR', `Failed to convert ${file.relativePath}: ${result.reason.message}`);
                }
            });
            
            // Progress update
            const processed = Math.min(i + CONFIG.concurrency, files.length);
            const percentage = ((processed / files.length) * 100).toFixed(1);
            log('INFO', `Progress: ${processed}/${files.length} (${percentage}%)`);
        }
        
        // Final summary
        const duration = ((Date.now() - startTime) / 1000).toFixed(1);
        
        log('INFO', '\n=== CONVERSION SUMMARY ===');
        log('INFO', `Total files: ${results.total}`);
        log('INFO', `Converted: ${results.converted}`);
        log('INFO', `Skipped (already exist): ${results.skipped}`);
        log('INFO', `Failed: ${results.failed}`);
        log('INFO', `Success rate: ${((results.converted / results.total) * 100).toFixed(1)}%`);
        log('INFO', `Duration: ${duration}s`);
        log('INFO', `Output directory: ${CONFIG.outputDir}`);
        
        if (results.failed > 0) {
            log('WARN', '\nFailed conversions:');
            results.errors.forEach(({ file, error }) => {
                log('WARN', `  ${file}: ${error}`);
            });
        }
        
        if (results.converted > 0) {
            log('SUCCESS', `Successfully converted ${results.converted} files!`);
        }
        
    } catch (error) {
        log('ERROR', `Batch conversion failed: ${error.message}`);
        console.error(error);
        process.exit(1);
    }
}

// Execute if run directly
import { fileURLToPath } from 'url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

if (import.meta.url === `file://${process.argv[1]}`) {
    main();
}

export { main, CONFIG };
