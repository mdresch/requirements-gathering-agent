#!/usr/bin/env node

/**
 * Full Batch PDF Conversion for Generated Documents
 * Converts all files in generated-documents directory to PDF
 */

import { promises as fs } from 'fs';
import path from 'path';
import { marked } from 'marked';
import puppeteer from 'puppeteer';

// Configuration
const CONFIG = {
    inputDir: './generated-documents',
    outputDir: './generated-documents-pdf',
    supportedExtensions: ['.md', '.txt', '.html'],
    concurrency: 2,
    timeout: 60000
};

// Logging
const log = (level, msg) => {
    const timestamp = new Date().toISOString();
    console.log(`[${level}] ${timestamp} - ${msg}`);
};

// Create professional HTML template
function createHTML(title, content, sourcePath) {
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <style>
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            line-height: 1.6;
            color: #2c3e50;
            margin: 0;
            padding: 40px;
            background: white;
        }
        .header {
            border-bottom: 3px solid #3498db;
            margin-bottom: 40px;
            padding-bottom: 20px;
        }
        .header h1 {
            color: #2c3e50;
            margin: 0 0 15px 0;
            font-size: 2.2em;
            font-weight: 300;
        }
        .meta {
            background: #f8f9fa;
            padding: 20px;
            border-left: 4px solid #3498db;
            margin-bottom: 30px;
            font-size: 0.9em;
            color: #666;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #2c3e50;
            margin-top: 30px;
            margin-bottom: 15px;
            line-height: 1.3;
        }
        h1 { font-size: 2em; border-bottom: 2px solid #ecf0f1; padding-bottom: 10px; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #ecf0f1; padding-bottom: 8px; }
        h3 { font-size: 1.3em; }
        p { margin-bottom: 16px; text-align: justify; }
        code {
            background: #f1f2f6;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
        }
        pre {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            border-left: 4px solid #3498db;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }
        blockquote {
            border-left: 4px solid #3498db;
            margin: 20px 0;
            padding: 10px 20px;
            background: #f8f9fa;
            font-style: italic;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px 15px;
            text-align: left;
        }
        th {
            background: #3498db;
            color: white;
            font-weight: 600;
        }
        tr:nth-child(even) { background: #f8f9fa; }
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ecf0f1;
            text-align: center;
            font-size: 0.8em;
            color: #7f8c8d;
        }
        @page {
            margin: 1in;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>${title}</h1>
    </div>
    <div class="meta">
        <strong>Source File:</strong> ${sourcePath}<br>
        <strong>Generated:</strong> ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}<br>
        <strong>Generated by:</strong> Requirements Gathering Agent - PDF Converter
    </div>
    <div class="content">
        ${content}
    </div>
    <div class="footer">
        Generated from ${sourcePath} | Requirements Gathering Agent
    </div>
</body>
</html>`;
}

// Process different file types
async function processFile(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    const content = await fs.readFile(filePath, 'utf-8');
    
    let htmlContent = '';
    let title = path.basename(filePath, ext).replace(/[-_]/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    
    switch (ext) {
        case '.md':
            htmlContent = marked(content, {
                gfm: true,
                breaks: true,
                headerIds: false,
                mangle: false
            });
            break;
            
        case '.txt':
            htmlContent = content
                .split('\n')
                .map(line => {
                    const trimmed = line.trim();
                    return trimmed ? `<p>${trimmed}</p>` : '<p>&nbsp;</p>';
                })
                .join('\n');
            break;
            
        case '.html':
            return content; // Return as-is for HTML files
            
        default:
            throw new Error(`Unsupported file type: ${ext}`);
    }
    
    return createHTML(title, htmlContent, filePath);
}

// Convert single file to PDF
async function convertToPDF(inputPath, outputPath) {
    let browser = null;
    
    try {
        // Process content
        const htmlContent = await processFile(inputPath);
        
        // Launch Puppeteer
        browser = await puppeteer.launch({
            headless: 'new',
            args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage'
            ]
        });
        
        const page = await browser.newPage();
        await page.setContent(htmlContent, {
            waitUntil: ['load', 'networkidle0'],
            timeout: CONFIG.timeout
        });
        
        // Generate PDF
        await page.pdf({
            path: outputPath,
            format: 'A4',
            margin: {
                top: '1in',
                right: '1in',
                bottom: '1in',
                left: '1in'
            },
            printBackground: true,
            preferCSSPageSize: false
        });
        
        return true;
        
    } catch (error) {
        throw new Error(`PDF conversion failed: ${error.message}`);
    } finally {
        if (browser) {
            await browser.close();
        }
    }
}

// Find all supported files recursively
async function findFiles(dir) {
    const files = [];
    
    async function scan(currentDir) {
        try {
            const entries = await fs.readdir(currentDir, { withFileTypes: true });
            
            for (const entry of entries) {
                const fullPath = path.join(currentDir, entry.name);
                
                if (entry.isDirectory()) {
                    await scan(fullPath);
                } else if (entry.isFile()) {
                    const ext = path.extname(entry.name).toLowerCase();
                    if (CONFIG.supportedExtensions.includes(ext)) {
                        files.push({
                            inputPath: fullPath,
                            relativePath: path.relative(dir, fullPath),
                            outputPath: path.join(CONFIG.outputDir, path.relative(dir, fullPath).replace(ext, '.pdf')),
                            extension: ext
                        });
                    }
                }
            }
        } catch (error) {
            log('ERROR', `Error scanning directory ${currentDir}: ${error.message}`);
        }
    }
    
    await scan(dir);
    return files;
}

// Process files in batches
async function processBatch(files, startIndex, batchSize) {
    const batch = files.slice(startIndex, startIndex + batchSize);
    const results = [];
    
    for (const file of batch) {
        try {
            // Ensure output directory exists
            await fs.mkdir(path.dirname(file.outputPath), { recursive: true });
            
            // Check if already exists
            try {
                await fs.access(file.outputPath);
                log('INFO', `Skipping ${file.relativePath} - already exists`);
                results.push({ file, skipped: true });
                continue;
            } catch {
                // File doesn't exist, proceed
            }
            
            // Convert file
            await convertToPDF(file.inputPath, file.outputPath);
            
            // Verify output
            const stats = await fs.stat(file.outputPath);
            const sizeKB = Math.round(stats.size / 1024);
            
            log('SUCCESS', `Converted ${file.relativePath} (${sizeKB} KB)`);
            results.push({ file, converted: true, size: sizeKB });
            
        } catch (error) {
            log('ERROR', `Failed to convert ${file.relativePath}: ${error.message}`);
            results.push({ file, error: error.message });
        }
    }
    
    return results;
}

// Main conversion function
async function main() {
    try {
        log('INFO', '🚀 Starting batch PDF conversion for generated documents...');
        
        // Ensure output directory exists
        await fs.mkdir(CONFIG.outputDir, { recursive: true });
        
        // Find all files
        log('INFO', `📂 Scanning ${CONFIG.inputDir}...`);
        const files = await findFiles(CONFIG.inputDir);
        
        if (files.length === 0) {
            log('WARN', '⚠️ No supported files found');
            return;
        }
        
        log('INFO', `📄 Found ${files.length} files to convert`);
        
        // Show breakdown by file type
        const breakdown = files.reduce((acc, file) => {
            acc[file.extension] = (acc[file.extension] || 0) + 1;
            return acc;
        }, {});
        
        Object.entries(breakdown).forEach(([ext, count]) => {
            log('INFO', `   ${ext}: ${count} files`);
        });
        
        // Process files in batches
        const results = {
            total: files.length,
            converted: 0,
            skipped: 0,
            failed: 0,
            totalSize: 0
        };
        
        const startTime = Date.now();
        
        for (let i = 0; i < files.length; i += CONFIG.concurrency) {
            const batchResults = await processBatch(files, i, CONFIG.concurrency);
            
            batchResults.forEach(result => {
                if (result.skipped) {
                    results.skipped++;
                } else if (result.converted) {
                    results.converted++;
                    results.totalSize += result.size || 0;
                } else {
                    results.failed++;
                }
            });
            
            // Progress update
            const processed = Math.min(i + CONFIG.concurrency, files.length);
            const percentage = ((processed / files.length) * 100).toFixed(1);
            log('INFO', `📊 Progress: ${processed}/${files.length} (${percentage}%)`);
        }
        
        // Final summary
        const duration = ((Date.now() - startTime) / 1000).toFixed(1);
        const avgSize = results.converted > 0 ? Math.round(results.totalSize / results.converted) : 0;
        
        log('INFO', '\n🎉 === CONVERSION COMPLETE ===');
        log('INFO', `📊 Total files: ${results.total}`);
        log('INFO', `✅ Converted: ${results.converted}`);
        log('INFO', `⏭️ Skipped: ${results.skipped}`);
        log('INFO', `❌ Failed: ${results.failed}`);
        log('INFO', `📈 Success rate: ${((results.converted / results.total) * 100).toFixed(1)}%`);
        log('INFO', `📁 Total size: ${Math.round(results.totalSize / 1024)} MB`);
        log('INFO', `📄 Average size: ${avgSize} KB`);
        log('INFO', `⏱️ Duration: ${duration}s`);
        log('INFO', `📂 Output: ${CONFIG.outputDir}`);
        
        if (results.converted > 0) {
            log('SUCCESS', `🎉 Successfully converted ${results.converted} files to PDF!`);
        }
        
    } catch (error) {
        log('ERROR', `❌ Batch conversion failed: ${error.message}`);
        console.error(error);
        process.exit(1);
    }
}

// Run main function
main().catch(error => {
    console.error('❌ Unexpected error:', error);
    process.exit(1);
});
