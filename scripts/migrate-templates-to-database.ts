/**
 * Template Migration Script
 * 
 * Migrates static GENERATION_TASKS to database-backed template system
 * while preserving all existing PMBOK standards and functionality.
 * 
 * This script will:
 * 1. Create database tables for templates
 * 2. Convert existing static templates to database records
 * 3. Preserve all AI instructions and generation logic
 * 4. Maintain backward compatibility
 */

import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';
import { GENERATION_TASKS } from '../src/modules/documentGenerator/generationTasks.js';

interface DatabaseTemplate {
    id: string;
    name: string;
    description: string;
    category: string;
    template_type: string;
    ai_instructions: string;
    prompt_template: string;
    generation_function: string;
    metadata: Record<string, any>;
    version: number;
    is_active: boolean;
    is_system: boolean;
    created_by: string;
    created_at: string;
}

/**
 * Generate UUID v4
 */
function generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

/**
 * Convert static generation task to database template
 */
function convertToTemplateRecord(task: any): DatabaseTemplate {
    return {
        id: generateUUID(),
        name: task.name,
        description: task.description || `${task.name} - PMBOK compliant ${task.category} document`,
        category: task.category,
        template_type: 'pmbok',
        ai_instructions: task.aiInstructions || `Generate a professional ${task.name} document following PMBOK 7.0 standards.`,
        prompt_template: generatePromptTemplate(task),
        generation_function: task.processorFunction || task.key,
        metadata: {
            emoji: task.emoji,
            key: task.key,
            originalIndex: GENERATION_TASKS.indexOf(task),
            pmbok_compliance: true,
            document_type: task.documentType || 'standard'
        },
        version: 1,
        is_active: true,
        is_system: true, // Mark as system template (from original static set)
        created_by: 'migration-script',
        created_at: new Date().toISOString()
    };
}

/**
 * Generate a standardized prompt template for each document type
 */
function generatePromptTemplate(task: any): string {
    return `
Generate a comprehensive ${task.name} document that:

1. Follows PMBOK 7.0 standards and best practices
2. Is appropriate for enterprise-level project management
3. Includes all required elements for ${task.category} documentation
4. Uses professional language and structure
5. Incorporates the provided project context effectively

Project Context: {{project_context}}

Additional Requirements:
- Use clear, professional language
- Include proper headers and formatting
- Ensure PMBOK compliance
- Add relevant tables, lists, and examples where appropriate
- Follow the document structure standards for ${task.category}

Output Format: Markdown
Document Type: ${task.name}
Category: ${task.category}
`;
}

/**
 * Create database schema SQL
 */
function generateDatabaseSchema(): string {
    return `
-- Template System Database Schema
-- Generated by Migration Script

-- Drop existing tables if they exist (for clean migration)
DROP TABLE IF EXISTS template_versions CASCADE;
DROP TABLE IF EXISTS templates CASCADE;
DROP TABLE IF EXISTS template_categories CASCADE;

-- Template categories for organization
CREATE TABLE template_categories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    description TEXT,
    parent_category_id UUID REFERENCES template_categories(id),
    sort_order INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Main templates table
CREATE TABLE templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(100) NOT NULL,
    template_type VARCHAR(50) DEFAULT 'pmbok',
    ai_instructions TEXT,
    prompt_template TEXT,
    generation_function VARCHAR(255),
    metadata JSONB DEFAULT '{}',
    version INTEGER DEFAULT 1,
    is_active BOOLEAN DEFAULT true,
    is_system BOOLEAN DEFAULT false,
    created_by VARCHAR(255),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    -- Add indexes for performance
    CONSTRAINT templates_name_check CHECK (length(name) > 0),
    CONSTRAINT templates_category_check CHECK (length(category) > 0)
);

-- Template versions for change tracking
CREATE TABLE template_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    template_id UUID REFERENCES templates(id) ON DELETE CASCADE,
    version INTEGER NOT NULL,
    changes JSONB DEFAULT '{}',
    change_summary TEXT,
    created_by VARCHAR(255),
    created_at TIMESTAMP DEFAULT NOW(),
    
    UNIQUE(template_id, version)
);

-- Indexes for performance
CREATE INDEX idx_templates_category ON templates(category);
CREATE INDEX idx_templates_active ON templates(is_active);
CREATE INDEX idx_templates_system ON templates(is_system);
CREATE INDEX idx_templates_created_at ON templates(created_at);
CREATE INDEX idx_template_versions_template_id ON template_versions(template_id);
CREATE INDEX idx_template_categories_parent ON template_categories(parent_category_id);

-- Insert categories from existing generation tasks
INSERT INTO template_categories (name, description, sort_order) VALUES
    ('basic-docs', 'Core project analysis and foundational documents', 1),
    ('project-charter', 'Project authorization and high-level planning documents', 2),
    ('management-plans', 'Comprehensive PMBOK management plans', 3),
    ('planning', 'Detailed planning documents and work breakdown structures', 4),
    ('scope-management', 'Project scope definition and control processes', 5),
    ('stakeholder-management', 'Stakeholder analysis and engagement strategies', 6),
    ('quality-assurance', 'Quality management and testing procedures', 7),
    ('technical-design', 'Technical architecture and system design', 8),
    ('technical-analysis', 'Technology assessment and compliance analysis', 9),
    ('implementation-guides', 'Development and deployment guidance', 10),
    ('risk-management', 'Risk identification and mitigation strategies', 11),
    ('strategic-statements', 'Mission, vision, and strategic planning', 12),
    ('requirements', 'Requirements gathering and analysis', 13);

-- Function to update the updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers to automatically update timestamps
CREATE TRIGGER update_templates_updated_at BEFORE UPDATE ON templates 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_template_categories_updated_at BEFORE UPDATE ON template_categories 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
`;
}

/**
 * Generate SQL INSERT statements for migrated templates
 */
function generateTemplateInserts(templates: DatabaseTemplate[]): string {
    const values = templates.map(template => {
        const metadata = JSON.stringify(template.metadata).replace(/'/g, "''");
        const aiInstructions = template.ai_instructions.replace(/'/g, "''");
        const promptTemplate = template.prompt_template.replace(/'/g, "''");
        const description = template.description.replace(/'/g, "''");
        
        return `('${template.id}', '${template.name}', '${description}', '${template.category}', 
                 '${template.template_type}', '${aiInstructions}', '${promptTemplate}', 
                 '${template.generation_function}', '${metadata}', ${template.version}, 
                 ${template.is_active}, ${template.is_system}, '${template.created_by}', 
                 '${template.created_at}')`;
    }).join(',\n    ');

    return `
-- Insert migrated templates from static GENERATION_TASKS
INSERT INTO templates (
    id, name, description, category, template_type, 
    ai_instructions, prompt_template, generation_function, 
    metadata, version, is_active, is_system, created_by, created_at
) VALUES
    ${values};
`;
}

/**
 * Main migration function
 */
export async function migrateTemplatesToDatabase(): Promise<void> {
    console.log('🚀 Starting Template Migration to Database...');
    
    try {
        // Convert all static templates to database format
        console.log(`📋 Converting ${GENERATION_TASKS.length} static templates...`);
        const databaseTemplates = GENERATION_TASKS.map(convertToTemplateRecord);
        
        // Generate database schema
        console.log('🏗️ Generating database schema...');
        const schema = generateDatabaseSchema();
        
        // Generate insert statements
        console.log('📝 Generating template insert statements...');
        const inserts = generateTemplateInserts(databaseTemplates);
        
        // Write migration files
        const migrationDir = join(process.cwd(), 'migrations');
        
        // Full migration SQL file
        const fullMigrationSQL = schema + inserts + `
-- Migration completed successfully
-- Total templates migrated: ${databaseTemplates.length}
-- Categories created: ${[...new Set(databaseTemplates.map(t => t.category))].length}

SELECT 
    'Migration completed!' as status,
    COUNT(*) as total_templates,
    COUNT(CASE WHEN is_system THEN 1 END) as system_templates,
    COUNT(DISTINCT category) as categories
FROM templates;
`;
        
        writeFileSync(join(migrationDir, '001_migrate_templates.sql'), fullMigrationSQL);
        
        // JSON export for backup/reference
        writeFileSync(
            join(migrationDir, 'migrated_templates.json'), 
            JSON.stringify(databaseTemplates, null, 2)
        );
        
        // TypeScript interface for the new template system
        const templateInterface = `
/**
 * Database Template Interface
 * Generated by migration script
 */
export interface DatabaseTemplate {
    id: string;
    name: string;
    description: string;
    category: string;
    template_type: string;
    ai_instructions: string;
    prompt_template: string;
    generation_function: string;
    metadata: Record<string, any>;
    version: number;
    is_active: boolean;
    is_system: boolean;
    created_by: string;
    created_at: string;
    updated_at?: string;
}

export interface TemplateCategory {
    id: string;
    name: string;
    description: string;
    parent_category_id?: string;
    sort_order: number;
}

export interface TemplateSearchQuery {
    category?: string;
    template_type?: string;
    is_active?: boolean;
    is_system?: boolean;
    search_text?: string;
    limit?: number;
    offset?: number;
}
`;
        
        writeFileSync(
            join(process.cwd(), 'src/types/databaseTemplates.ts'), 
            templateInterface
        );
        
        console.log('✅ Migration completed successfully!');
        console.log(`📁 Files generated:`);
        console.log(`   - migrations/001_migrate_templates.sql (${fullMigrationSQL.length} bytes)`);
        console.log(`   - migrations/migrated_templates.json (${JSON.stringify(databaseTemplates).length} bytes)`);
        console.log(`   - src/types/databaseTemplates.ts`);
        console.log(`📊 Migration statistics:`);
        console.log(`   - Templates migrated: ${databaseTemplates.length}`);
        console.log(`   - Categories: ${[...new Set(databaseTemplates.map(t => t.category))].length}`);
        console.log(`   - System templates: ${databaseTemplates.filter(t => t.is_system).length}`);
        
    } catch (error) {
        console.error('❌ Migration failed:', error);
        throw error;
    }
}

// Run migration if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
    migrateTemplatesToDatabase().catch(console.error);
}
